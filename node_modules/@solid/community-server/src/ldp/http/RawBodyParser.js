"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawBodyParser = void 0;
const UnsupportedHttpError_1 = require("../../util/errors/UnsupportedHttpError");
const BodyParser_1 = require("./BodyParser");
/**
 * Converts incoming {@link HttpRequest} to a Representation without any further parsing.
 * Naively parses the mediatype from the content-type header.
 * Some other metadata is also generated, but this should probably be done in an external handler.
 */
class RawBodyParser extends BodyParser_1.BodyParser {
    async canHandle() {
        // All content-types are supported
    }
    // Note that the only reason this is a union is in case the body is empty.
    // If this check gets moved away from the BodyParsers this union could be removed
    async handle(input) {
        // RFC7230, ยง3.3: The presence of a message body in a request
        // is signaled by a Content-Length or Transfer-Encoding header field.
        if (!input.headers['content-length'] && !input.headers['transfer-encoding']) {
            return;
        }
        // While RFC7231 allows treating a body without content type as an octet stream,
        // such an omission likely signals a mistake, so force clients to make this explicit.
        if (!input.headers['content-type']) {
            throw new Error('An HTTP request body was passed without Content-Type header');
        }
        return {
            binary: true,
            data: input,
            metadata: this.parseMetadata(input),
        };
    }
    parseMetadata(input) {
        const contentType = /^[^;]*/u.exec(input.headers['content-type'])[0];
        const metadata = {
            raw: [],
            contentType,
        };
        const { link, slug } = input.headers;
        if (slug) {
            if (Array.isArray(slug)) {
                throw new UnsupportedHttpError_1.UnsupportedHttpError('At most 1 slug header is allowed.');
            }
            metadata.slug = slug;
        }
        // There are similarities here to Accept header parsing so that library should become more generic probably
        if (link) {
            metadata.linkRel = {};
            const linkArray = Array.isArray(link) ? link : [link];
            const parsedLinks = linkArray.map((entry) => {
                var _a, _b;
                const [, url, rest] = (_a = /^<([^>]*)>(.*)$/u.exec(entry)) !== null && _a !== void 0 ? _a : [];
                const [, rel] = (_b = /^ *; *rel="(.*)"$/u.exec(rest)) !== null && _b !== void 0 ? _b : [];
                return { url, rel };
            });
            parsedLinks.forEach((entry) => {
                if (entry.rel) {
                    if (!metadata.linkRel[entry.rel]) {
                        metadata.linkRel[entry.rel] = new Set();
                    }
                    metadata.linkRel[entry.rel].add(entry.url);
                }
            });
        }
        return metadata;
    }
}
exports.RawBodyParser = RawBodyParser;
//# sourceMappingURL=RawBodyParser.js.map