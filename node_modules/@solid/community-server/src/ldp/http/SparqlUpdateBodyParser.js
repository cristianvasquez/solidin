"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparqlUpdateBodyParser = void 0;
const stream_1 = require("stream");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const UnsupportedHttpError_1 = require("../../util/errors/UnsupportedHttpError");
const UnsupportedMediaTypeHttpError_1 = require("../../util/errors/UnsupportedMediaTypeHttpError");
const Util_1 = require("../../util/Util");
const BodyParser_1 = require("./BodyParser");
/**
 * {@link BodyParser} that supports `application/sparql-update` content.
 * Will convert the incoming update string to algebra in a {@link SparqlUpdatePatch}.
 * Still needs access to a handler for parsing metadata.
 */
class SparqlUpdateBodyParser extends BodyParser_1.BodyParser {
    async canHandle(input) {
        const contentType = input.headers['content-type'];
        if (!contentType || contentType !== 'application/sparql-update') {
            throw new UnsupportedMediaTypeHttpError_1.UnsupportedMediaTypeHttpError('This parser only supports SPARQL UPDATE data.');
        }
    }
    async handle(input) {
        try {
            // Note that readableObjectMode is only defined starting from Node 12
            // It is impossible to check if object mode is enabled in Node 10 (without accessing private variables)
            const options = { objectMode: input.readableObjectMode };
            const toAlgebraStream = new stream_1.PassThrough(options);
            const dataCopy = new stream_1.PassThrough(options);
            input.pipe(toAlgebraStream);
            input.pipe(dataCopy);
            const sparql = await Util_1.readableToString(toAlgebraStream);
            const algebra = sparqlalgebrajs_1.translate(sparql, { quads: true });
            // Prevent body from being requested again
            return {
                algebra,
                binary: true,
                data: dataCopy,
                metadata: {
                    raw: [],
                    profiles: [],
                    contentType: 'application/sparql-update',
                },
            };
        }
        catch (error) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError(error);
        }
    }
}
exports.SparqlUpdateBodyParser = SparqlUpdateBodyParser;
//# sourceMappingURL=SparqlUpdateBodyParser.js.map