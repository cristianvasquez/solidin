"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebAclAuthorizer = void 0;
const n3_1 = require("n3");
const ContentTypes_1 = require("../util/ContentTypes");
const ForbiddenHttpError_1 = require("../util/errors/ForbiddenHttpError");
const NotFoundHttpError_1 = require("../util/errors/NotFoundHttpError");
const UnauthorizedHttpError_1 = require("../util/errors/UnauthorizedHttpError");
const AclConstants_1 = require("./AclConstants");
const Authorizer_1 = require("./Authorizer");
/**
 * Handles most web access control predicates such as
 * `acl:mode`, `acl:agentClass`, `acl:agent`, `acl:default` and `acl:accessTo`.
 * Does not support `acl:agentGroup`, `acl:origin` and `acl:trustedApp` yet.
 */
class WebAclAuthorizer extends Authorizer_1.Authorizer {
    constructor(aclManager, containerManager, resourceStore) {
        super();
        this.aclManager = aclManager;
        this.containerManager = containerManager;
        this.resourceStore = resourceStore;
    }
    async canHandle() {
        // Can handle everything
    }
    /**
     * Checks if an agent is allowed to execute the requested actions.
     * Will throw an error if this is not the case.
     * @param input - Relevant data needed to check if access can be granted.
     */
    async handle(input) {
        const store = await this.getAclRecursive(input.identifier);
        if (await this.aclManager.isAcl(input.identifier)) {
            this.checkPermission(input.credentials, store, 'control');
        }
        else {
            Object.keys(input.permissions).forEach((key) => {
                if (input.permissions[key]) {
                    this.checkPermission(input.credentials, store, key);
                }
            });
        }
    }
    /**
     * Checks if any of the triples in the store grant the agent permission to use the given mode.
     * Throws a {@link ForbiddenHttpError} or {@link UnauthorizedHttpError} depending on the credentials
     * if access is not allowed.
     * @param agent - Agent that wants access.
     * @param store - A store containing the relevant triples for authorization.
     * @param mode - Which mode is requested. Probable one of ('write' | 'read' | 'append' | 'control').
     */
    checkPermission(agent, store, mode) {
        const modeString = AclConstants_1.ACL[this.capitalize(mode)];
        const auths = store.getQuads(null, AclConstants_1.ACL.mode, modeString, null).map((quad) => quad.subject);
        if (!auths.some((term) => this.hasAccess(agent, term, store))) {
            throw typeof agent.webID === 'string' ? new ForbiddenHttpError_1.ForbiddenHttpError() : new UnauthorizedHttpError_1.UnauthorizedHttpError();
        }
    }
    /**
     * Capitalizes the input string.
     * @param mode - String to transform.
     *
     * @returns The capitalized string.
     */
    capitalize(mode) {
        return `${mode[0].toUpperCase()}${mode.slice(1).toLowerCase()}`;
    }
    /**
     * Checks if the given agent has access to the modes specified by the given authorization.
     * @param agent - Credentials of agent that needs access.
     * @param auth - acl:Authorization that needs to be checked.
     * @param store - A store containing the relevant triples of the authorization.
     *
     * @returns If the agent has access.
     */
    hasAccess(agent, auth, store) {
        if (store.countQuads(auth, AclConstants_1.ACL.agentClass, AclConstants_1.FOAF.Agent, null) > 0) {
            return true;
        }
        if (typeof agent.webID !== 'string') {
            return false;
        }
        if (store.countQuads(auth, AclConstants_1.ACL.agentClass, AclConstants_1.FOAF.AuthenticatedAgent, null) > 0) {
            return true;
        }
        return store.countQuads(auth, AclConstants_1.ACL.agent, agent.webID, null) > 0;
    }
    /**
     * Returns the acl triples that are relevant for the given identifier.
     * These can either be from a corresponding acl file or an acl file higher up with defaults.
     * Rethrows any non-NotFoundHttpErrors thrown by the AclManager or ResourceStore.
     * @param id - ResourceIdentifier of which we need the acl triples.
     * @param recurse - Only used internally for recursion.
     *
     * @returns A store containing the relevant acl triples.
     */
    async getAclRecursive(id, recurse) {
        try {
            const acl = await this.aclManager.getAcl(id);
            const data = await this.resourceStore.getRepresentation(acl, { type: [{ value: ContentTypes_1.INTERNAL_QUADS, weight: 1 }] });
            return this.filterData(data, recurse ? AclConstants_1.ACL.default : AclConstants_1.ACL.accessTo, id.path);
        }
        catch (error) {
            if (!(error instanceof NotFoundHttpError_1.NotFoundHttpError)) {
                throw error;
            }
            const parent = await this.containerManager.getContainer(id);
            return this.getAclRecursive(parent, true);
        }
    }
    /**
     * Finds all triples in the data stream of the given representation that use the given predicate and object.
     * Then extracts the unique subjects from those triples,
     * and returns a Store containing all triples from the data stream that have such a subject.
     *
     * This can be useful for finding the `acl:Authorization` objects corresponding to a specific URI
     * and returning all relevant information on them.
     * @param data - Representation with data stream of internal/quads.
     * @param predicate - Predicate to match.
     * @param object - Object to match.
     *
     * @returns A store containing the relevant triples.
     */
    async filterData(data, predicate, object) {
        const store = new n3_1.Store();
        const importEmitter = store.import(data.data);
        await new Promise((resolve, reject) => {
            importEmitter.on('end', resolve);
            importEmitter.on('error', reject);
        });
        const auths = store.getQuads(null, predicate, object, null).map((quad) => quad.subject);
        const newStore = new n3_1.Store();
        auths.forEach((subject) => newStore.addQuads(store.getQuads(subject, null, null, null)));
        return newStore;
    }
}
exports.WebAclAuthorizer = WebAclAuthorizer;
//# sourceMappingURL=WebAclAuthorizer.js.map