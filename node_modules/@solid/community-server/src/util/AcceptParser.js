"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAcceptLanguage = exports.parseAcceptEncoding = exports.parseAcceptCharset = exports.parseAccept = void 0;
const UnsupportedHttpError_1 = require("./errors/UnsupportedHttpError");
// REUSED REGEXES
const token = /^[a-zA-Z0-9!#$%&'*+-.^_`|~]+$/u;
// HELPER FUNCTIONS
/**
 * Replaces all double quoted strings in the input string with `"0"`, `"1"`, etc.
 * @param input - The Accept header string.
 *
 * @returns The transformed string and a map with keys `"0"`, etc. and values the original string that was there.
 */
const transformQuotedStrings = (input) => {
    let idx = 0;
    const replacements = {};
    const result = input.replace(/"(?:[^"\\]|\\.)*"/gu, (match) => {
        // Not all characters allowed in quoted strings, see BNF above
        if (!/^"(?:[\t !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|(?:\\[\t\u0020-\u007e\u0080-\u00ff]))*"$/u.test(match)) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid quoted string in Accept header: ${match}. Check which characters are allowed`);
        }
        const replacement = `"${idx}"`;
        replacements[replacement] = match;
        idx += 1;
        return replacement;
    });
    return { result, replacements };
};
/**
 * Splits the input string on commas, trims all parts and filters out empty ones.
 *
 * @param input - Input header string.
 */
const splitAndClean = (input) => input.split(',')
    .map((part) => part.trim())
    .filter((part) => part.length > 0);
/**
 * Checks if the input string matches the qvalue regex.
 *
 * @param qvalue - Input qvalue string (so "q=....").
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid syntax.
 */
const testQValue = (qvalue) => {
    if (!/^q=(?:(?:0(?:\.\d{0,3})?)|(?:1(?:\.0{0,3})?))$/u.test(qvalue)) {
        throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid q value: ${qvalue} does not match ("q=" ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )).`);
    }
};
/**
 * Parses a single media range with corresponding parameters from an Accept header.
 * For every parameter value that is a double quoted string,
 * we check if it is a key in the replacements map.
 * If yes the value from the map gets inserted instead.
 *
 * @param part - A string corresponding to a media range and its corresponding parameters.
 * @param replacements - The double quoted strings that need to be replaced.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid type, qvalue or parameter syntax.
 *
 * @returns {@link Accept} object corresponding to the header string.
 */
const parseAcceptPart = (part, replacements) => {
    const [range, ...parameters] = part.split(';').map((param) => param.trim());
    // No reason to test differently for * since we don't check if the type exists
    const [type, subtype] = range.split('/');
    if (!type || !subtype || !token.test(type) || !token.test(subtype)) {
        throw new Error(`Invalid Accept range: ${range} does not match ( "*/*" / ( token "/" "*" ) / ( token "/" token ) )`);
    }
    let weight = 1;
    const mediaTypeParams = {};
    const extensionParams = {};
    let map = mediaTypeParams;
    parameters.forEach((param) => {
        const [name, value] = param.split('=');
        if (name === 'q') {
            // Extension parameters appear after the q value
            map = extensionParams;
            testQValue(param);
            weight = parseFloat(value);
        }
        else {
            // Test replaced string for easier check
            // parameter  = token "=" ( token / quoted-string )
            // second part is optional for extension parameters
            if (!token.test(name) ||
                !((map === extensionParams && !value) || (value && (/^"\d+"$/u.test(value) || token.test(value))))) {
                throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid Accept parameter: ${param} does not match (token "=" ( token / quoted-string )). ` +
                    `Second part is optional for extension parameters.`);
            }
            let actualValue = value;
            if (value && value.length > 0 && value.startsWith('"') && replacements[value]) {
                actualValue = replacements[value];
            }
            // Value is optional for extension parameters
            map[name] = actualValue || '';
        }
    });
    return {
        range,
        weight,
        parameters: {
            mediaType: mediaTypeParams,
            extension: extensionParams,
        },
    };
};
/**
 * Parses an Accept-* header where each part is only a value and a weight, so roughly /.*(q=.*)?/ separated by commas.
 * @param input - Input header string.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid qvalue syntax.
 *
 * @returns An array of ranges and weights.
 */
const parseNoParameters = (input) => {
    const parts = splitAndClean(input);
    return parts.map((part) => {
        const [range, qvalue] = part.split(';').map((param) => param.trim());
        const result = { range, weight: 1 };
        if (qvalue) {
            testQValue(qvalue);
            result.weight = parseFloat(qvalue.split('=')[1]);
        }
        return result;
    }).sort((left, right) => right.weight - left.weight);
};
// EXPORTED FUNCTIONS
/**
 * Parses an Accept header string.
 *
 * @param input - The Accept header string.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid header syntax.
 *
 * @returns An array of {@link Accept} objects, sorted by weight.
 */
exports.parseAccept = (input) => {
    // Quoted strings could prevent split from having correct results
    const { result, replacements } = transformQuotedStrings(input);
    return splitAndClean(result)
        .map((part) => parseAcceptPart(part, replacements))
        .sort((left, right) => right.weight - left.weight);
};
/**
 * Parses an Accept-Charset header string.
 *
 * @param input - The Accept-Charset header string.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid header syntax.
 *
 * @returns An array of {@link AcceptCharset} objects, sorted by weight.
 */
exports.parseAcceptCharset = (input) => {
    const results = parseNoParameters(input);
    results.forEach((result) => {
        if (!token.test(result.range)) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid Accept-Charset range: ${result.range} does not match (content-coding / "identity" / "*")`);
        }
    });
    return results;
};
/**
 * Parses an Accept-Encoding header string.
 *
 * @param input - The Accept-Encoding header string.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid header syntax.
 *
 * @returns An array of {@link AcceptEncoding} objects, sorted by weight.
 */
exports.parseAcceptEncoding = (input) => {
    const results = parseNoParameters(input);
    results.forEach((result) => {
        if (!token.test(result.range)) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid Accept-Encoding range: ${result.range} does not match (charset / "*")`);
        }
    });
    return results;
};
/**
 * Parses an Accept-Language header string.
 *
 * @param input - The Accept-Language header string.
 *
 * @throws {@link UnsupportedHttpError}
 * Thrown on invalid header syntax.
 *
 * @returns An array of {@link AcceptLanguage} objects, sorted by weight.
 */
exports.parseAcceptLanguage = (input) => {
    const results = parseNoParameters(input);
    results.forEach((result) => {
        // (1*8ALPHA *("-" 1*8alphanum)) / "*"
        if (result.range !== '*' && !/^[a-zA-Z]{1,8}(?:-[a-zA-Z0-9]{1,8})*$/u.test(result.range)) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError(`Invalid Accept-Language range: ${result.range} does not match ((1*8ALPHA *("-" 1*8alphanum)) / "*")`);
        }
    });
    return results;
};
//# sourceMappingURL=AcceptParser.js.map