"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockingResourceStore = void 0;
/** Time in ms after which reading a representation times out, causing the lock to be released. */
const READ_TIMEOUT = 1000;
/**
 * Store that for every call acquires a lock before executing it on the requested resource,
 * and releases it afterwards.
 */
class LockingResourceStore {
    constructor(source, locks) {
        this.source = source;
        this.locks = locks;
    }
    async getRepresentation(identifier, preferences, conditions) {
        return this.lockedRepresentationRun(identifier, async () => this.source.getRepresentation(identifier, preferences, conditions));
    }
    async addResource(container, representation, conditions) {
        return this.lockedRun(container, async () => this.source.addResource(container, representation, conditions));
    }
    async setRepresentation(identifier, representation, conditions) {
        return this.lockedRun(identifier, async () => this.source.setRepresentation(identifier, representation, conditions));
    }
    async deleteResource(identifier, conditions) {
        return this.lockedRun(identifier, async () => this.source.deleteResource(identifier, conditions));
    }
    async modifyResource(identifier, patch, conditions) {
        return this.lockedRun(identifier, async () => this.source.modifyResource(identifier, patch, conditions));
    }
    /**
     * Acquires a lock for the identifier and releases it when the function is executed.
     * @param identifier - Identifier that should be locked.
     * @param func - Function to be executed.
     */
    async lockedRun(identifier, func) {
        const lock = await this.locks.acquire(identifier);
        try {
            return await func();
        }
        finally {
            await lock.release();
        }
    }
    /**
     * Acquires a lock for the identifier that should return a representation with Readable data and releases it when the
     * Readable is read, closed or results in an error.
     * When using this function, it is required to close the Readable stream when you are ready.
     *
     * @param identifier - Identifier that should be locked.
     * @param func - Function to be executed.
     */
    async lockedRepresentationRun(identifier, func) {
        const lock = await this.locks.acquire(identifier);
        let representation;
        try {
            // Make the resource time out to ensure that the lock is always released eventually.
            representation = await func();
            return this.createExpiringRepresentation(representation);
        }
        finally {
            // If the representation contains a valid Readable, wait for it to be consumed.
            const data = representation === null || representation === void 0 ? void 0 : representation.data;
            if (!data) {
                await lock.release();
            }
            else {
                // When an error occurs, destroy the readable so the lock is released safely.
                data.on('error', () => data.destroy());
                // An `end` and/or `close` event signals that the readable has been consumed.
                new Promise((resolve) => {
                    data.on('end', resolve);
                    data.on('close', resolve);
                }).then(() => lock.release(), null);
            }
        }
    }
    /**
     * Wraps a representation to make it time out when nothing is read for a certain amount of time.
     *
     * @param source - The representation to wrap
     */
    createExpiringRepresentation(source) {
        return Object.create(source, {
            data: { value: this.createExpiringReadable(source.data) },
        });
    }
    /**
     * Wraps a readable to make it time out when nothing is read for a certain amount of time.
     *
     * @param source - The readable to wrap
     */
    createExpiringReadable(source) {
        // Destroy the source when a timeout occurs.
        const destroySource = () => source.destroy(new Error(`Stream reading timout of ${READ_TIMEOUT}ms exceeded`));
        let timeout = setTimeout(destroySource, READ_TIMEOUT);
        // Cancel the timeout when the source terminates by itself.
        const cancelTimeout = () => clearTimeout(timeout);
        source.on('error', cancelTimeout);
        source.on('end', cancelTimeout);
        // Spy on the source to reset the timeout on read.
        return Object.create(source, {
            read: {
                value(size) {
                    cancelTimeout();
                    timeout = setTimeout(destroySource, READ_TIMEOUT);
                    return source.read(size);
                },
            },
        });
    }
}
exports.LockingResourceStore = LockingResourceStore;
//# sourceMappingURL=LockingResourceStore.js.map