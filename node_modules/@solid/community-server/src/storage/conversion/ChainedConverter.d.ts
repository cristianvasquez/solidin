import { Representation } from '../../ldp/representation/Representation';
import { RepresentationConverterArgs } from './RepresentationConverter';
import { TypedRepresentationConverter } from './TypedRepresentationConverter';
/**
 * A meta converter that takes an array of other converters as input.
 * It chains these converters by finding intermediate types that are supported by converters on either side.
 */
export declare class ChainedConverter extends TypedRepresentationConverter {
    private readonly converters;
    /**
     * Creates the chain of converters based on the input.
     * The list of `converters` needs to be at least 2 long.
     * @param converters - The chain of converters.
     */
    constructor(converters: TypedRepresentationConverter[]);
    protected get first(): TypedRepresentationConverter;
    protected get last(): TypedRepresentationConverter;
    getInputTypes(): Promise<{
        [contentType: string]: number;
    }>;
    getOutputTypes(): Promise<{
        [contentType: string]: number;
    }>;
    canHandle(input: RepresentationConverterArgs): Promise<void>;
    handle(input: RepresentationConverterArgs): Promise<Representation>;
    /**
     * Finds the best media type that can be used to chain 2 converters.
     */
    protected getMatchingType(left: TypedRepresentationConverter, right: TypedRepresentationConverter): Promise<string>;
}
