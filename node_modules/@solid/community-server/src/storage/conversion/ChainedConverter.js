"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainedConverter = void 0;
const Util_1 = require("../../util/Util");
const TypedRepresentationConverter_1 = require("./TypedRepresentationConverter");
/**
 * A meta converter that takes an array of other converters as input.
 * It chains these converters by finding intermediate types that are supported by converters on either side.
 */
class ChainedConverter extends TypedRepresentationConverter_1.TypedRepresentationConverter {
    /**
     * Creates the chain of converters based on the input.
     * The list of `converters` needs to be at least 2 long.
     * @param converters - The chain of converters.
     */
    constructor(converters) {
        super();
        if (converters.length < 2) {
            throw new Error('At least 2 converters are required.');
        }
        this.converters = [...converters];
    }
    get first() {
        return this.converters[0];
    }
    get last() {
        return this.converters[this.converters.length - 1];
    }
    async getInputTypes() {
        return this.first.getInputTypes();
    }
    async getOutputTypes() {
        return this.last.getOutputTypes();
    }
    async canHandle(input) {
        // We assume a chain can be constructed, otherwise there would be a configuration issue
        // Check if the first converter can handle the input
        const firstChain = await this.getMatchingType(this.converters[0], this.converters[1]);
        const preferences = { type: [{ value: firstChain, weight: 1 }] };
        await this.first.canHandle(Object.assign(Object.assign({}, input), { preferences }));
        // Check if the last converter can produce the output
        const idx = this.converters.length - 1;
        const lastChain = await this.getMatchingType(this.converters[idx - 1], this.converters[idx]);
        const representation = Object.assign({}, input.representation);
        representation.metadata = Object.assign(Object.assign({}, input.representation.metadata), { contentType: lastChain });
        await this.last.canHandle(Object.assign(Object.assign({}, input), { representation }));
    }
    async handle(input) {
        const args = Object.assign({}, input);
        for (let i = 0; i < this.converters.length - 1; ++i) {
            const value = await this.getMatchingType(this.converters[i], this.converters[i + 1]);
            args.preferences = { type: [{ value, weight: 1 }] };
            args.representation = await this.converters[i].handle(args);
        }
        args.preferences = input.preferences;
        return this.last.handle(args);
    }
    /**
     * Finds the best media type that can be used to chain 2 converters.
     */
    async getMatchingType(left, right) {
        const leftTypes = await left.getOutputTypes();
        const rightTypes = await right.getInputTypes();
        let bestMatch = { type: 'invalid', weight: 0 };
        // Try to find the matching type with the best weight
        const leftKeys = Object.keys(leftTypes);
        const rightKeys = Object.keys(rightTypes);
        for (const leftType of leftKeys) {
            const leftWeight = leftTypes[leftType];
            if (leftWeight <= bestMatch.weight) {
                continue;
            }
            for (const rightType of rightKeys) {
                const rightWeight = rightTypes[rightType];
                const weight = leftWeight * rightWeight;
                if (weight > bestMatch.weight && Util_1.matchingMediaType(leftType, rightType)) {
                    bestMatch = { type: leftType, weight };
                    if (weight === 1) {
                        return bestMatch.type;
                    }
                }
            }
        }
        if (bestMatch.weight === 0) {
            throw new Error(`No match found between ${leftKeys} and ${rightKeys}`);
        }
        return bestMatch.type;
    }
}
exports.ChainedConverter = ChainedConverter;
//# sourceMappingURL=ChainedConverter.js.map