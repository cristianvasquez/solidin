"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TurtleToQuadConverter = void 0;
const stream_1 = require("stream");
const n3_1 = require("n3");
const ContentTypes_1 = require("../../util/ContentTypes");
const UnsupportedHttpError_1 = require("../../util/errors/UnsupportedHttpError");
const ConversionUtil_1 = require("./ConversionUtil");
const RepresentationConverter_1 = require("./RepresentationConverter");
/**
 * Converts `text/turtle` to `internal/quads`.
 */
class TurtleToQuadConverter extends RepresentationConverter_1.RepresentationConverter {
    async canHandle(input) {
        ConversionUtil_1.checkRequest(input, [ContentTypes_1.TEXT_TURTLE], [ContentTypes_1.INTERNAL_QUADS]);
    }
    async handle(input) {
        return this.turtleToQuads(input.representation, input.identifier.path);
    }
    turtleToQuads(turtle, baseIRI) {
        const metadata = Object.assign(Object.assign({}, turtle.metadata), { contentType: ContentTypes_1.INTERNAL_QUADS });
        // Catch parsing errors and emit correct error
        // Node 10 requires both writableObjectMode and readableObjectMode
        const errorStream = new stream_1.PassThrough({ writableObjectMode: true, readableObjectMode: true });
        const data = turtle.data.pipe(new n3_1.StreamParser({ format: ContentTypes_1.TEXT_TURTLE, baseIRI }));
        data.pipe(errorStream);
        data.on('error', (error) => errorStream.emit('error', new UnsupportedHttpError_1.UnsupportedHttpError(error.message)));
        return {
            binary: false,
            data: errorStream,
            metadata,
        };
    }
}
exports.TurtleToQuadConverter = TurtleToQuadConverter;
//# sourceMappingURL=TurtleToQuadConverter.js.map