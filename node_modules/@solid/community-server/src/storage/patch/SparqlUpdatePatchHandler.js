"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparqlUpdatePatchHandler = void 0;
const data_model_1 = require("@rdfjs/data-model");
const n3_1 = require("n3");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const ContentTypes_1 = require("../../util/ContentTypes");
const UnsupportedHttpError_1 = require("../../util/errors/UnsupportedHttpError");
const PatchHandler_1 = require("./PatchHandler");
/**
 * PatchHandler that supports specific types of SPARQL updates.
 * Currently all DELETE/INSERT types are supported that have empty where bodies and no variables.
 */
class SparqlUpdatePatchHandler extends PatchHandler_1.PatchHandler {
    constructor(source, locker) {
        super();
        this.source = source;
        this.locker = locker;
    }
    async canHandle(input) {
        if (typeof input.patch.algebra !== 'object') {
            throw new UnsupportedHttpError_1.UnsupportedHttpError('Only SPARQL update patch requests are supported.');
        }
    }
    async handle(input) {
        var _a, _b, _c;
        const op = input.patch.algebra;
        if (!this.isDeleteInsert(op)) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError('Only DELETE/INSERT SPARQL update operations are supported.');
        }
        const def = data_model_1.defaultGraph();
        const deletes = (_a = op.delete) !== null && _a !== void 0 ? _a : [];
        const inserts = (_b = op.insert) !== null && _b !== void 0 ? _b : [];
        if (!deletes.every((pattern) => pattern.graph.equals(def))) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError('GRAPH statements are not supported.');
        }
        if (!inserts.every((pattern) => pattern.graph.equals(def))) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError('GRAPH statements are not supported.');
        }
        if ((_c = op.where) !== null && _c !== void 0 ? _c : deletes.some((pattern) => rdf_terms_1.someTerms(pattern, (term) => term.termType === 'Variable'))) {
            throw new UnsupportedHttpError_1.UnsupportedHttpError('WHERE statements are not supported.');
        }
        const lock = await this.locker.acquire(input.identifier);
        const quads = await this.source.getRepresentation(input.identifier, { type: [{ value: ContentTypes_1.INTERNAL_QUADS, weight: 1 }] });
        const store = new n3_1.Store();
        const importEmitter = store.import(quads.data);
        await new Promise((resolve, reject) => {
            importEmitter.on('end', resolve);
            importEmitter.on('error', reject);
        });
        store.removeQuads(deletes);
        store.addQuads(inserts);
        const representation = {
            binary: false,
            data: store.match(),
            metadata: {
                raw: [],
                profiles: [],
                contentType: ContentTypes_1.INTERNAL_QUADS,
            },
        };
        await this.source.setRepresentation(input.identifier, representation);
        await lock.release();
    }
    isDeleteInsert(op) {
        return op.type === sparqlalgebrajs_1.Algebra.types.DELETE_INSERT;
    }
}
exports.SparqlUpdatePatchHandler = SparqlUpdatePatchHandler;
//# sourceMappingURL=SparqlUpdatePatchHandler.js.map