"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryResourceStore = void 0;
const stream_1 = require("stream");
const arrayify_stream_1 = __importDefault(require("arrayify-stream"));
const streamify_array_1 = __importDefault(require("streamify-array"));
const ContentTypes_1 = require("../util/ContentTypes");
const NotFoundHttpError_1 = require("../util/errors/NotFoundHttpError");
const Util_1 = require("../util/Util");
/**
 * Resource store storing its data in an in-memory map.
 * Current Solid functionality support is quite basic: containers are not really supported for example.
 */
class InMemoryResourceStore {
    /**
     * @param runtimeConfig - Config containing base that will be stripped of all incoming URIs
     *                        and added to all outgoing ones to find the relative path.
     */
    constructor(runtimeConfig) {
        this.index = 0;
        this.runtimeConfig = runtimeConfig;
        this.store = {
            // Default root entry (what you get when the identifier is equal to the base)
            '': {
                binary: true,
                data: streamify_array_1.default([]),
                metadata: { raw: [], profiles: [], contentType: ContentTypes_1.TEXT_TURTLE },
            },
        };
    }
    /**
     * Stores the incoming data under a new URL corresponding to `container.path + number`.
     * Slash added when needed.
     * @param container - The identifier to store the new data under.
     * @param representation - Data to store.
     *
     * @returns The newly generated identifier.
     */
    async addResource(container, representation) {
        const containerPath = this.parseIdentifier(container);
        this.checkPath(containerPath);
        const newID = { path: `${Util_1.ensureTrailingSlash(container.path)}${this.index}` };
        const newPath = this.parseIdentifier(newID);
        this.index += 1;
        this.store[newPath] = await this.copyRepresentation(representation);
        return newID;
    }
    /**
     * Deletes the given resource.
     * @param identifier - Identifier of resource to delete.
     */
    async deleteResource(identifier) {
        const path = this.parseIdentifier(identifier);
        this.checkPath(path);
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this.store[path];
    }
    /**
     * Returns the stored representation for the given identifier.
     * Preferences will be ignored, data will be returned as it was received.
     *
     * @param identifier - Identifier to retrieve.
     *
     * @returns The corresponding Representation.
     */
    async getRepresentation(identifier) {
        const path = this.parseIdentifier(identifier);
        this.checkPath(path);
        return this.generateRepresentation(path);
    }
    /**
     * @throws Not supported.
     */
    async modifyResource() {
        throw new Error('Not supported.');
    }
    /**
     * Puts the given data in the given location.
     * @param identifier - Identifier to replace.
     * @param representation - New Representation.
     */
    async setRepresentation(identifier, representation) {
        const path = this.parseIdentifier(identifier);
        this.store[path] = await this.copyRepresentation(representation);
    }
    /**
     * Strips the base from the identifier and checks if it is valid.
     * @param identifier - Incoming identifier.
     *
     * @throws {@link NotFoundHttpError}
     * If the identifier doesn't start with the base ID.
     *
     * @returns A string representing the relative path.
     */
    parseIdentifier(identifier) {
        const path = identifier.path.slice(this.runtimeConfig.base.length);
        if (!identifier.path.startsWith(this.runtimeConfig.base)) {
            throw new NotFoundHttpError_1.NotFoundHttpError();
        }
        return path;
    }
    /**
     * Checks if the relative path is in the store.
     * @param path - Incoming identifier.
     *
     * @throws {@link NotFoundHttpError}
     * If the path is not in the store.
     */
    checkPath(path) {
        if (!this.store[path]) {
            throw new NotFoundHttpError_1.NotFoundHttpError();
        }
    }
    /**
     * Copies the Representation by draining the original data stream and creating a new one.
     *
     * @param source - Incoming Representation.
     */
    async copyRepresentation(source) {
        const arr = await arrayify_stream_1.default(source.data);
        return {
            binary: source.binary,
            data: streamify_array_1.default([...arr]),
            metadata: source.metadata,
        };
    }
    /**
     * Generates a Representation that is identical to the one stored,
     * but makes sure to duplicate the data stream so it stays readable for later calls.
     *
     * @param path - Path in store of Representation.
     *
     * @returns The resulting Representation.
     */
    async generateRepresentation(path) {
        // Note: when converting to a complete ResourceStore and using readable-stream
        // object mode should be set correctly here (now fixed due to Node 10)
        const source = this.store[path];
        const objectMode = { writableObjectMode: true, readableObjectMode: true };
        const streamOutput = new stream_1.PassThrough(objectMode);
        const streamInternal = new stream_1.PassThrough(Object.assign(Object.assign({}, objectMode), { highWaterMark: Number.MAX_SAFE_INTEGER }));
        source.data.pipe(streamOutput);
        source.data.pipe(streamInternal);
        source.data = streamInternal;
        return {
            binary: source.binary,
            data: streamOutput,
            metadata: source.metadata,
        };
    }
}
exports.InMemoryResourceStore = InMemoryResourceStore;
//# sourceMappingURL=InMemoryResourceStore.js.map